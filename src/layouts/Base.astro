---
import TwSizeIndicator from "@components/TwSizeIndicator.astro";
import config from "@config/config.json";
import theme from "@config/theme.json";
import { plainify } from "@lib/utils/textConverter";
import Footer from "@partials/Footer.astro";
import Header from "@partials/Header/Header.astro";
import "@styles/main.scss";
import ContactButton from "./function-components/ContactButton";
import ChatWidget from "./function-components/ChatWidget";
import { ViewTransitions } from "astro:transitions";
import { getEntryBySlug } from "astro:content";

// font families
const pf = theme.fonts.font_family.primary;
const sf = theme.fonts.font_family.secondary;

// types for frontmatters
export interface Props {
  title?: string;
  meta_title?: string;
  description?: string;
  image?: string;
  noindex?: boolean;
  canonical?: string;
  is404?: boolean;
}

// distructure frontmatters
const { title, meta_title, description, image, noindex, canonical, is404 = false } =
  Astro.props;

 
const { currentLocale } = Astro
// console.log("currentLocale")
// console.log(currentLocale)

const fallbackLocale = "es";
let chatContent = await getEntryBySlug("layout", `${currentLocale ?? fallbackLocale}/chatbot`);
if (!chatContent) {
  chatContent = await getEntryBySlug("layout", `${fallbackLocale}/chatbot`);
}

let contactButtonEntry = await getEntryBySlug("layout", `${currentLocale ?? fallbackLocale}/contact_button`);
if (!contactButtonEntry) {
  contactButtonEntry = await getEntryBySlug("layout", `${fallbackLocale}/contact_button`);
}

const siteTitle = config.site.title;
const pageTitle = meta_title ?? title;
const fullTitle = pageTitle ? `${pageTitle} | ${siteTitle}` : siteTitle;
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- favicon -->
    <link rel="shortcut icon" href={config.site.favicon} />

    <!-- theme meta -->
    <meta name="theme-name" content="pinwheel-astro" />
    <meta name="msapplication-TileColor" content="#000000" />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: light)"
      content="#fff"
    />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: dark)"
      content="#000"
    />
    <meta name="generator" content={Astro.generator} />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Evita parpadeo al aplicar el tema correcto antes del render -->
    <script is:inline>
      (function() {
        const LS_KEY = "appTheme";
        const root = document.documentElement;

        /** Aplica el tema segun localStorage o preferencia del sistema */
        function applyTheme() {
          try {
            const storedTheme = localStorage.getItem(LS_KEY);
            const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
            const theme = storedTheme || (prefersDark ? "dark" : "light");

            root.classList.toggle("dark", theme === "dark");
            root.style.colorScheme = theme === "dark" ? "dark" : "light";
          } catch (e) {
            console.warn("Theme apply failed:", e);
          }
        }

        // Ejecutar antes del primer render
        applyTheme();

        // üîÅ Reaplicar despu√©s de cada transici√≥n de p√°gina
        document.addEventListener("astro:after-swap", applyTheme);
      })();
    </script>

    <!-- google font css -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href={`https://fonts.googleapis.com/css2?family=${pf}${
        sf ? "&family=" + sf : ""
      }&display=swap`}
      rel="stylesheet"
    />

    <!-- responsive meta -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=5"
    />

    <!-- title -->
    <title>{plainify(fullTitle)}</title>
    
    <ViewTransitions/>
    
    <!-- canonical url -->
    {canonical && <link rel="canonical" href={canonical} item-prop="url" />}

    <!-- noindex robots -->
    {noindex && <meta name="robots" content="noindex,nofollow" />}

    <!-- meta-description -->
    <meta
      name="description"
      content={plainify(
        description ? description : config.metadata.meta_description
      )}
    />

    <!-- author from config.json -->
    <meta name="author" content={config.metadata.meta_author} />

    <!-- og-title -->
    <meta
      property="og:title"
      content={plainify(fullTitle)}
    />

    <!-- og-description -->
    <meta
      property="og:description"
      content={plainify(
        description ? description : config.metadata.meta_description
      )}
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content={`${config.site.base_url}/${Astro.url.pathname.replace("/", "")}`}
    />

    <!-- twitter-title -->
    <meta
      name="twitter:title"
      content={plainify(fullTitle)}
    />

    <!-- twitter-description -->
    <meta
      name="twitter:description"
      content={plainify(
        description ? description : config.metadata.meta_description
      )}
    />

    <!-- og-image -->
    <meta
      property="og:image"
      content={`${config.site.base_url}${
        image ? image : config.metadata.meta_image
      }`}
    />

    <!-- twitter-image -->
    <meta
      name="twitter:image"
      content={`${config.site.base_url}${
        image ? image : config.metadata.meta_image
      }`}
    />
    <meta name="twitter:card" content="summary_large_image" />
  </head>
  <body>
    <TwSizeIndicator />
    <Header is404={is404}/>
    <main id="main-content">
      <slot />
    </main>
    <Footer />
    <ContactButton
      message={contactButtonEntry?.data?.message}
      client:load/>
    <ChatWidget chatContent={chatContent?.data} client:load />

    <script>
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const type = entry.target.dataset.animate;
            const transitionClasses = [
              'transition-all',
              'duration-[1200ms]',
              'ease-[cubic-bezier(0.25,0.1,0.25,1)]',
            ];

            // üîπ Quita las clases iniciales de invisibilidad y desplazamiento
            entry.target.classList.remove('opacity-0', 'translate-y-20', 'translate-x-20', 'scale-95');

            // üîπ Aplica clases finales (posici√≥n natural + visible)
            switch (type) {
              case 'fade-up':
                entry.target.classList.add('opacity-100', 'translate-y-0');
                break;
              case 'fade-right':
                entry.target.classList.add('opacity-100', 'translate-x-0');
                break;
              case 'zoom-in':
                entry.target.classList.add('opacity-100', 'scale-100');
                break;
            }

            // üîπ Evita transiciones posteriores por cambios de layout (ej. men√∫ mobile)
            //    quitando las clases de transici√≥n despu√©s del primer render
            requestAnimationFrame(() => {
              entry.target.classList.remove(...transitionClasses);
            });

            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.15 });

      document.querySelectorAll('[data-animate]').forEach(el => {
        const type = el.dataset.animate;

        // üîπ Estado inicial: invisible y desplazado *desde* su posici√≥n final
        const baseClasses = [
          'opacity-0',
          'transition-all',
          'duration-[1200ms]', // ‚Üê tiempo (ajusta libremente)
          'ease-[cubic-bezier(0.25,0.1,0.25,1)]', // ‚Üê suavidad natural
        ];

        // üîπ Diferente direcci√≥n inicial seg√∫n el tipo de animaci√≥n
        if (type === 'fade-up') baseClasses.push('translate-y-20');
        if (type === 'fade-right') baseClasses.push('translate-x-20');
        if (type === 'zoom-in') baseClasses.push('scale-95');

        el.classList.add(...baseClasses);
        observer.observe(el);
      });

      document.addEventListener("astro:after-swap", () => {
      document.querySelectorAll('[data-animate]').forEach(el => observer.observe(el));
      });

      const SCROLL_STORAGE_KEY = 'lang-switch-scroll-ratio';

      function restoreScrollPosition() {
        try {
          const stored = sessionStorage.getItem(SCROLL_STORAGE_KEY);
          if (!stored) return;

          sessionStorage.removeItem(SCROLL_STORAGE_KEY);
          const { ratio } = JSON.parse(stored);

          requestAnimationFrame(() => {
            const scrollable = document.documentElement.scrollHeight - window.innerHeight;
            if (scrollable <= 0) return;

            const target = Math.max(0, Math.round(scrollable * (typeof ratio === 'number' ? ratio : 0)));
            window.scrollTo({ top: target, behavior: 'auto' });
          });
        } catch (error) {
          console.warn('No se pudo restaurar la posici√≥n de scroll', error);
        }
      }

      if (document.readyState === 'complete') {
        restoreScrollPosition();
      } else {
        window.addEventListener('load', restoreScrollPosition, { once: true });
      }

      document.addEventListener('astro:after-swap', restoreScrollPosition);

    </script>

  </body>
</html>
