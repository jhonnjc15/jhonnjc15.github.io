---
import { markdownify } from "@lib/utils/textConverter";
const { gallery } = Astro.props;
const { title, description, images } = gallery;

const TARGET_WIDTH = 1200;
const TARGET_HEIGHT = 1300;

const defaultSizes = ["feature", "portrait", "landscape", "portrait", "statement"];

const sizeMap: Record<string, { rows: number; cols: number }> = {
  feature: { rows: 26, cols: 2 },
  portrait: { rows: 22, cols: 1 },
  landscape: { rows: 18, cols: 2 },
  square: { rows: 18, cols: 1 },
  tall: { rows: 26, cols: 1 },
  wide: { rows: 18, cols: 2 },
  medium: { rows: 20, cols: 1 },
  statement: { rows: 24, cols: 1 },
};

const normalizeImage = (image: any, index: number) => {
  if (typeof image === "string") {
    const size = defaultSizes[index % defaultSizes.length];
    const base = sizeMap[size] || sizeMap.portrait;

    return {
      src: image,
      alt: title,
      size,
      rows: base.rows,
      cols: base.cols,
    };
  }

  const normalizedSize = image.size || defaultSizes[index % defaultSizes.length];
  const base = sizeMap[normalizedSize] || sizeMap.portrait;

  return {
    ...image,
    size: normalizedSize,
    rows: image.rows || base.rows,
    cols: image.cols || base.cols,
  };
};

const computeLayout = (
  normalized: Array<{ rows: number; cols: number }>,
  opts: { width?: number; height?: number } = {},
) => {
  const targetWidth = opts.width || TARGET_WIDTH;
  const targetHeight = opts.height || TARGET_HEIGHT;

  const columns = targetWidth >= 900 ? 3 : 2;
  const rowUnit = Math.max(12, Math.round(targetHeight / 120));
  const targetRows = Math.max(28, Math.round(targetHeight / rowUnit));

  const columnHeights = Array.from({ length: columns }).fill(0) as number[];
  const placements: Array<{ rows: number; cols: number; column: number }> = [];

  normalized.forEach((image) => {
    const spanCols = Math.min(image.cols || 1, columns);
    const candidateRows = Math.max(10, image.rows);

    let bestColumn = 0;
    let bestHeight = Number.POSITIVE_INFINITY;

    for (let col = 0; col <= columns - spanCols; col++) {
      const heightHere = Math.max(...columnHeights.slice(col, col + spanCols));
      if (heightHere < bestHeight) {
        bestHeight = heightHere;
        bestColumn = col;
      }
    }

    for (let offset = 0; offset < spanCols; offset++) {
      columnHeights[bestColumn + offset] += candidateRows;
    }

    placements.push({ rows: candidateRows, cols: spanCols, column: bestColumn });
  });

  const maxHeight = Math.max(...columnHeights, targetRows);

  // Stretch the last tile in each column so every column reaches the same height.
  columnHeights.forEach((height, columnIndex) => {
    const gap = maxHeight - height;
    if (gap <= 0) return;

    const lastIndex = [...placements]
      .map((placement, idx) => ({ ...placement, idx }))
      .filter((placement) =>
        placement.column === columnIndex && placement.cols === 1
          ? true
          : placement.column <= columnIndex && columnIndex < placement.column + placement.cols,
      )
      .map((placement) => placement.idx)
      .pop();

    if (lastIndex === undefined) return;

    placements[lastIndex].rows += gap;
    columnHeights[columnIndex] += gap;
  });

  return { placements, columns, rowUnit };
};

const baseItems = images.map((image: any, index: number) => normalizeImage(image, index));
const { placements, columns, rowUnit } = computeLayout(baseItems, {
  width: TARGET_WIDTH,
  height: TARGET_HEIGHT,
});

const galleryItems = baseItems.map((item, index) => ({
  ...item,
  rows: placements[index]?.rows || item.rows,
  cols: placements[index]?.cols || item.cols,
}));
---

<section class="section">
  <div class="container">
    <div class="row justify-center text-center">
      <div class="col-10 lg:col-8 space-y-3">
        <p class="text-xs uppercase tracking-[0.25em] text-secondary font-semibold" set:html={markdownify(title)} />
        <h2 class="text-3xl md:text-4xl font-extrabold text-default" set:html={markdownify(title)} />
        {description && (
          <p class="text-text-offset leading-relaxed" set:html={markdownify(description)} />
        )}
      </div>
    </div>

    <div class="gallery-shell" id="photo-gallery">
      <div
        class="masonry"
        style={{
          "--columns": columns,
          "--row-unit": `${rowUnit}px`,
        }}
      >
        {galleryItems.map((image) => (
          <div
            class={`picture-item group ${image.cols > 1 ? "picture-item--wide" : ""}`}
            style={{
              "--rows": image.rows,
              "--cols": image.cols,
            }}
          >
            <div class="picture-surface">
              <img
                class="picture-img"
                src={image.src}
                alt={image.alt || title}
                loading="lazy"
              />
            </div>
          </div>
        ))}
      </div>
    </div>
  </div>
</section>

<style lang="scss">
  .gallery-shell {
    position: relative;
    max-width: 76rem;
    margin: 0 auto;
    padding: clamp(1rem, 2.25vw, 1.75rem);
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(238, 243, 255, 0.95));
    border-radius: 22px;
    border: 2px solid rgba(89, 116, 255, 0.14);
    box-shadow: 0 30px 60px -30px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(12, 18, 43, 0.06);
  }

  .masonry {
    display: grid;
    grid-template-columns: repeat(var(--columns, 3), minmax(0, 1fr));
    grid-auto-rows: var(--row-unit, 12px);
    grid-auto-flow: dense;
    gap: clamp(0.65rem, 1vw, 0.9rem);
  }

  .picture-item {
    grid-row-end: span var(--rows, 18);
    grid-column-end: span var(--cols, 1);
    border-radius: 16px;
    overflow: hidden;
    min-height: 140px;
  }

  .picture-item--wide {
    min-height: 180px;
  }

  .picture-surface {
    position: relative;
    height: 100%;
    width: 100%;
    background: rgba(255, 255, 255, 0.78);
    box-shadow: 0 14px 32px -16px rgba(0, 0, 0, 0.35);
    border: 1px solid rgba(15, 23, 42, 0.08);
    border-radius: inherit;
    overflow: hidden;
  }

  .picture-img {
    height: 100%;
    width: 100%;
    object-fit: cover;
    transition: transform 320ms ease-out;
    display: block;
  }

  .group:hover .picture-img,
  .group:focus-visible .picture-img {
    transform: scale(1.04);
  }
</style>
